import string;
import runtime;
import ds/tree;
import lingo/pegcode/driver;
import net/url_parameter;
import fs/filesystem;
import mygrammar;

lingoGrammarOpAr : ref Maybe<[PegOp]> = ref None();
lingoGrammarOpPol : ref Maybe<[PegOp]> = ref None();

lingoGrammarAr() {
	onlyOnce(lingoGrammarOpAr, \ -> {
		compilePegGrammar("#include /home/prozella/stuff/flow9/lib/lingo/mygrammar.lingo");
	});
}

lingoGrammarPol() {
	onlyOnce(lingoGrammarOpPol, \ -> {
		compilePegGrammar("#include /home/prozella/stuff/flow9/lib/lingo/rpn.lingo");
	});
}

astToStr(exp : Exp){
	switch(exp : Exp){
		Val(val):{
			print(d2s(val));
		}
		Var(var):{
			print(var);
		}
		Add(e1,e2):{
			print("(");
			astToStr(e1);
			print("+");
			astToStr(e2);
			print(")");
		}
		Sub(e1,e2):{
			print("(");
			astToStr(e1);
			print("-");
			astToStr(e2);
			print(")");
		}
		Div(e1,e2):{
			print("(");
			astToStr(e1);
			print("/");
			astToStr(e2);
			print(")");
		}
		Mul(e1,e2):{
			print("(");
			astToStr(e1);
			print("*");
			astToStr(e2);
			print(")");
		}
		Pow(e1,e2):{
			print("(");
			astToStr(e1);
			print("^");
			astToStr(e2);
			print(")");
		}
	}
}

calculateAst(exp : Exp){
	switch(exp : Exp){
		Val(val):{
			val;
		}
		Var(var):{
			s2d(getUrlParameter(var));
		}
		Add(e1,e2):{
			calculateAst(e1) + calculateAst(e2);
		}
		Sub(e1,e2):{
			calculateAst(e1) - calculateAst(e2);
		}
		Div(e1,e2):{
			calculateAst(e1) / calculateAst(e2);
		}
		Mul(e1,e2):{
			calculateAst(e1) * calculateAst(e2);
		}
		Pow(e1,e2):{
			dpow(calculateAst(e1), calculateAst(e2))
		}
	}
}

makeRPNString(exp : Exp) -> string{
	switch(exp : Exp){
		Val(val):{
			d2s(val) + " ";
		}
		Var(var):{
			var + " ";
		}
		Add(e1,e2):{
			makeRPNString(e1) + makeRPNString(e2) + "+ "
		}
		Sub(e1,e2):{
			makeRPNString(e1) + makeRPNString(e2) + "- "
		}
		Div(e1,e2):{
			makeRPNString(e1) + makeRPNString(e2) + "/ "
		}
		Mul(e1,e2):{
			makeRPNString(e1) + makeRPNString(e2) + "* "
		}
		Pow(e1,e2):{
			makeRPNString(e1) + makeRPNString(e2) + "^ "
		}
	}
}

calculatePolish(elements : [Elem], curIndex : int, maxIndex : int, stack : [double], freeStackIndex : int) -> double{
	if(curIndex > maxIndex){
		stack[freeStackIndex - 1]
	}
	else{
		elem = elements[curIndex];
		switch(elem : Elem){
			Val(val):{
				calculatePolish(elements, curIndex + 1, maxIndex, replace(stack,freeStackIndex,val), freeStackIndex + 1)
			}
			Var(var):{
				calculatePolish(elements, curIndex + 1, maxIndex, replace(stack,freeStackIndex,s2d(getUrlParameter(var))), freeStackIndex + 1)
			}
			Op(op):{
				if(op == "*"){
					res = stack[freeStackIndex - 2] *stack[freeStackIndex - 1];
					calculatePolish(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if(op == "/"){
					res = stack[freeStackIndex - 2]  / stack[freeStackIndex - 1];
					calculatePolish(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if(op == "-"){
					res = stack[freeStackIndex - 2] - stack[freeStackIndex - 1];
					calculatePolish(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if (op == "^"){
					res = dpow(stack[freeStackIndex - 2], stack[freeStackIndex - 1]);
					calculatePolish(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else{	
					res = stack[freeStackIndex - 2] + stack[freeStackIndex - 1];
					calculatePolish(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
			}
		}
	}
}

polishToAr(elements : [Elem], curIndex : int, maxIndex : int, stack : [string], freeStackIndex : int) -> string{
	if(curIndex > maxIndex){
		stack[freeStackIndex-1]
	}
	else{
		elem = elements[curIndex];
		switch(elem : Elem){
			Val(val):{
				polishToAr(elements, curIndex + 1, maxIndex, replace(stack,freeStackIndex,d2s(val)), freeStackIndex + 1)
			}
			Var(var):{
				polishToAr(elements, curIndex + 1, maxIndex, replace(stack,freeStackIndex,var), freeStackIndex + 1)
			}
			Op(op):{
				if(op == "*"){
					res = "(" + stack[freeStackIndex - 2] + "*" + stack[freeStackIndex - 1] + ")";
					polishToAr(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if(op == "/"){
					res = "(" + stack[freeStackIndex - 2] + "/" + stack[freeStackIndex - 1] + ")";
					polishToAr(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if(op == "-"){
					res = "(" + stack[freeStackIndex - 2] + "-" + stack[freeStackIndex - 1] + ")";
					polishToAr(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else if (op == "^"){
					res = "(" + stack[freeStackIndex - 2] + "^" + stack[freeStackIndex - 1] + ")";
					polishToAr(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
				else{	
					res = "(" + stack[freeStackIndex - 2] + "+" + stack[freeStackIndex - 1] + ")";
					polishToAr(elements, curIndex + 1, maxIndex, replace(stack, freeStackIndex-2, res), freeStackIndex - 1)
				}
			}
		}
	}
}

makeOneSimplification(exp : Exp){
	switch(exp : Exp){
		Add(e1,e2):{
			if(e1 == Val(0.0)){
				e2
			}
			else if(e2 == Val(0.0)){
				e1
			} else{
				exp
			}
		} 
		Mul(e1,e2):{
			if(e1 == Val(1.0)){
				e2
			}
			else if(e2 == Val(1.0)){
				e1
			}
			else if(e1 == Val(0.0) || e2 == Val(0.0)){
				Val(0.0)
			}
		  else if(isSameStructType(e1, Pow(e1,e2))){
				pow_obj = cast(e1 : Exp -> Pow);
				if(pow_obj.e1 == e2){
					Pow(e2, Add(pow_obj.e2, Val(1.0)))
				} else {
					exp
				}
			}
			else if(isSameStructType(e2, Pow(e1,e2))){
				pow_obj = cast(e2 : Exp -> Pow);
				if(pow_obj.e1 == e1){
					Pow(e1, Add(pow_obj.e2, Val(1.0)))
				}
				else{
					exp
				}
			}
			else {
				exp
			}
		}
		Pow(e1,e2):{
			exp
		}
		Val(val):{
			exp
		}
		Var(var):{
			exp
		};
		Sub(e1,e2):{
			if(e1 == e2){
				Val(0.0)
			} else {
				exp
			}
		}
		Div(e1,e2):{
			exp
		}
	}
}

makeSimpleTree(exp : Exp) -> Exp{
	switch(exp : Exp){
		Add(e1,e2):{
			if(e1 == Val(0.0)){
				makeSimpleTree(e2);
			}
			else if(e2 == Val(0.0)){
				makeSimpleTree(e1);
			} else{
				new_e1 = makeSimpleTree(e1);
				new_e2 = makeSimpleTree(e2);
				makeOneSimplification(Add(new_e1,new_e2));
			}
		} 
		Mul(e1,e2):{
			if(e1 == Val(1.0)){
				makeSimpleTree(e2);
			}
			else if(e2 == Val(1.0)){
				makeSimpleTree(e1);
			}
			else if(e1 == Val(0.0) || e2 == Val(0.0)){
				Val(0.0)
			}
			else if(e1 == e2){
				makeOneSimplification(Pow(makeSimpleTree(e1), Val(2.0)))
			}
			else if(isSameStructType(e1, Pow(e1,e2))){
				pow_obj = cast(e1 : Exp -> Pow);
				new_pow_e1 = makeSimpleTree(pow_obj.e1);
				new_e2 = makeSimpleTree(e2);
				if(new_pow_e1 == new_e2){
					makeOneSimplification(Pow(new_pow_e1, Add(pow_obj.e2, Val(1.0))))
				} else {
					new_e1 = makeSimpleTree(e1);
					makeOneSimplification(Mul(new_e1, new_e2))
				}
			}
			else if(isSameStructType(e2, Pow(e1,e2))){
				pow_obj = cast(e2 : Exp -> Pow);
				new_pow_e1 = makeSimpleTree(pow_obj.e1);
				new_e1 = makeSimpleTree(e1);
				if(new_pow_e1 == new_e1){
					makeOneSimplification(Pow(new_pow_e1, Add(pow_obj.e2, Val(1.0))))
				}
				else{
					new_e2 = makeSimpleTree(e2);
					makeOneSimplification(Mul(new_e1, new_e2))
				}
			}
		  else {
				new_e1 = makeSimpleTree(e1);
				new_e2 = makeSimpleTree(e2);
				makeOneSimplification(Mul(new_e1,new_e2));
			}
		}
		Pow(e1,e2):{
			Pow(makeSimpleTree(e1),makeSimpleTree(e2))
		}
		Val(val):{
			exp
		}
		Var(var):{
			exp
		};
		Sub(e1,e2):{
			if(e1 == e2){
				Val(0.0)
			} else {
			makeOneSimplification(Sub(makeSimpleTree(e1),makeSimpleTree(e2)))
			}
		}
		Div(e1,e2):{
			Div(makeSimpleTree(e1),makeSimpleTree(e2))
		}
	}
}

main() {
	isSameStructType(Pow(Val(1.0), Var("a")), Pow(Var("a"), Val(5.05))) |> println;
  str : string = strsubsmart(readUntil("\n"), 0,-1);	
	//lab5
	resultAr = parsic(lingoGrammarAr(), str, defaultPegActions);
  resultAr |> println;
	//lab6
	r = cast(resultAr : flow -> Exp);
	astToStr(r);
	println("");
	//lab7
	calculateAst(resultAr) |> println;
	//lab8
	polish = makeRPNString(resultAr);
	polish |> println;
	resultPol = parsic(lingoGrammarPol(), polish, defaultPegActions);
	println(resultPol);
	polishToAr(resultPol, 0,length(resultPol) - 1, [], 0) |> println;
	//lab9?
	println(calculatePolish(resultPol,0, length(resultPol) - 1, [], 0));

	makeSimpleTree(r) |> println;
	
}